$signature = @"
[DllImport("netapi32.dll", SetLastError = true)]
public static extern int NetShareEnum(
    string servername,
    int level,
    out IntPtr bufptr,
    int prefmaxlen,
    out int entriesread,
    out int totalentries,
    out int resume_handle
);
"@

# Next, add the PInvoke signature to the current PowerShell session
Add-Type -MemberDefinition $signature -Namespace Win32 -Name NetApi32

# Then, call NetShareEnum to retrieve a list of local shares
$serverName = $null  # null means local machine
$level = 2  # use level 2 for detailed share information
$prefMaxLen = -1  # -1 means allocate as much memory as necessary
$bufPtr = [IntPtr]::Zero
$entriesRead = 0
$totalEntries = 0
$resumeHandle = 0

$netApiResult = [Win32.NetApi32]::NetShareEnum($serverName, $level, [ref] $bufPtr, $prefMaxLen, [ref] $entriesRead, [ref] $totalEntries, [ref] $resumeHandle)

if ($netApiResult -eq 0) {
    # Convert the unmanaged memory to a managed array of SHARE_INFO_2 structs
    $shareInfoType = [Win32.NetApi32+SHARE_INFO_2]
    $shareInfoArray = New-Object -TypeName $shareInfoType[] -ArgumentList $entriesRead
    [Runtime.InteropServices.Marshal]::Copy($bufPtr, $shareInfoArray, 0, $entriesRead)

    # Print the share names
    foreach ($shareInfo in $shareInfoArray) {
        Write-Host $shareInfo.shi2_netname
    }

    # Free the unmanaged memory
    [Win32.NetApi32]::NetApiBufferFree($bufPtr) | Out-Null
}
else {
    Write-Error "NetShareEnum failed with error code $netApiResult"
}
